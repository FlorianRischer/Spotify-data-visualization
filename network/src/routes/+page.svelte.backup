<script lang="ts">
  import { onMount } from "svelte";
  import { GraphCanvas, ControlPanel, Tooltip } from "$lib/components";
  import { graphData, initVisible, setPositions } from "$lib/stores";
  import { buildGraph, computeForceLayout, transformSpotifyData } from "$lib/graph";
  
  // Spotify API Credentials
  const SPOTIFY_CLIENT_ID = '0d00211b45094412aa9b8207af9ab2ff';
  const SPOTIFY_CLIENT_SECRET = '9c230d9ec1c447ba8f4b72004cb95c2a';
  
  let isLoading = true;
  let loadingStatus = "LÃ¤dt Streaming-Daten...";
  
  // Cache functions
  const CACHE_KEY = 'spotify_artist_cache';
  const CACHE_VERSION = 'v1';
  
  function loadCache(): Map<string, any> {
    try {
      const cached = localStorage.getItem(CACHE_KEY);
      if (cached) {
        const { version, data, timestamp } = JSON.parse(cached);
        // Cache fÃ¼r 7 Tage gÃ¼ltig
        if (version === CACHE_VERSION && Date.now() - timestamp < 7 * 24 * 60 * 60 * 1000) {
          console.log('ðŸ’¾ Loaded', Object.keys(data).length, 'artists from cache');
          return new Map(Object.entries(data));
        }
      }
    } catch (e) {
      console.warn('Failed to load cache:', e);
    }
    return new Map();
  }
  
  function saveCache(cache: Map<string, any>) {
    try {
      const data = Object.fromEntries(cache);
      localStorage.setItem(CACHE_KEY, JSON.stringify({
        version: CACHE_VERSION,
        data,
        timestamp: Date.now()
      }));
      console.log('ðŸ’¾ Saved', cache.size, 'artists to cache');
    } catch (e) {
      console.warn('Failed to save cache:', e);
    }
  }
  
  async function getSpotifyToken(): Promise<string> {
    const response = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Authorization': 'Basic ' + btoa(SPOTIFY_CLIENT_ID + ':' + SPOTIFY_CLIENT_SECRET)
      },
      body: 'grant_type=client_credentials'
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Spotify token error:', response.status, errorText);
      throw new Error(`Failed to get Spotify token: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('Spotify token obtained successfully');
    return `Bearer ${data.access_token}`;
  }
  
  async function searchArtist(artistName: string, token: string, retries = 3): Promise<any> {
    if (!artistName || artistName.trim() === '') return null;
    
    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        const response = await fetch(
          `https://api.spotify.com/v1/search?q=${encodeURIComponent(artistName)}&type=artist&limit=1`,
          {
            headers: { 'Authorization': token }
          }
        );
        
        // Log rate limit info
        const remaining = response.headers.get('X-RateLimit-Remaining');
        const limit = response.headers.get('X-RateLimit-Limit');
        const reset = response.headers.get('X-RateLimit-Reset');
        
        if (remaining && limit) {
          const percentRemaining = (parseInt(remaining) / parseInt(limit)) * 100;
          if (percentRemaining < 20) {
            console.warn(`âš ï¸ Rate limit low: ${remaining}/${limit} (${percentRemaining.toFixed(0)}%)`);
          }
        }
        
        if (response.status === 429) {
          // Rate limit hit - check for Retry-After header
          const retryAfter = response.headers.get('Retry-After');
          const resetTime = reset ? parseInt(reset) * 1000 : null;
          let waitTime;
          
          if (retryAfter) {
            waitTime = parseInt(retryAfter) * 1000;
          } else if (resetTime) {
            waitTime = Math.max(resetTime - Date.now(), 1000);
          } else {
            waitTime = Math.pow(2, attempt) * 1000;
          }
          
          if (attempt < retries) {
            console.warn(`âš ï¸ Rate limit hit for "${artistName}", waiting ${Math.round(waitTime/1000)}s (attempt ${attempt + 1}/${retries})`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
            continue;
          }
          return null;
        }
        
        if (!response.ok) {
          if (response.status === 401) {
            console.error('âŒ Spotify API: Unauthorized - token may be invalid');
          }
          return null;
        }
        
        const data = await response.json();
        
        if (data.artists && data.artists.items && data.artists.items.length > 0) {
          const artist = data.artists.items[0];
          return {
            id: artist.id,
            name: artist.name,
            genres: artist.genres || [],
            popularity: artist.popularity,
            followers: artist.followers.total
          };
        }
        
        return null;
      } catch (error) {
        if (attempt < retries) {
          const waitTime = Math.pow(2, attempt) * 1000;
          console.warn(`âš ï¸ Network error for "${artistName}", retrying in ${waitTime}ms...`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          continue;
        }
        console.error(`âŒ Error searching for artist "${artistName}":`, error);
        return null;
      }
    }
    
    return null;
  }
  
  async function getArtistsWithGenres(uniqueArtists: string[], token: string) {
    const artistsWithGenres = [];
    let batchSize = 10; // Start with 10
    let successCount = 0;
    let rateLimitHits = 0;
    let currentDelay = 200; // Dynamic delay
    
    // Load cache
    const cache = loadCache();
    const uncachedArtists = uniqueArtists.filter(name => !cache.has(name));
    
    console.log(`ðŸ“Š ${cache.size} artists in cache, ${uncachedArtists.length} need to be fetched`);
    
    // Add cached artists
    for (const [name, data] of cache.entries()) {
      if (uniqueArtists.includes(name)) {
        artistsWithGenres.push(data);
        if (data.genres && data.genres.length > 0) successCount++;
      }
    }
    
    // Fetch uncached artists
    for (let i = 0; i < uncachedArtists.length; i += batchSize) {
      const batch = uncachedArtists.slice(i, i + batchSize);
      const progress = Math.round((i / uncachedArtists.length) * 100);
      loadingStatus = `Lade Artist-Genres (${i + batch.length}/${uncachedArtists.length})... ${progress}% [Delay: ${currentDelay}ms]`;
      
      const promises = batch.map(async (artistName) => {
        const artistInfo = await searchArtist(artistName, token);
        const result = {
          originalName: artistName,
          ...artistInfo
        };
        
        // Add to cache
        cache.set(artistName, result);
        
        if (artistInfo && artistInfo.genres && artistInfo.genres.length > 0) {
          successCount++;
        }
        return result;
      });
      
      const results = await Promise.all(promises);
      artistsWithGenres.push(...results);
      
      // Save cache periodically (every 10 batches)
      if (i % (batchSize * 10) === 0) {
        saveCache(cache);
      }
      
      // Adaptive delay: increase if we're getting close to limits
      // Decrease if everything is smooth
      const failureRate = results.filter(r => !r.id).length / results.length;
      if (failureRate > 0.3) {
        // Many failures, slow down
        currentDelay = Math.min(currentDelay * 1.5, 2000);
        console.warn(`âš ï¸ High failure rate, increasing delay to ${currentDelay}ms`);
      } else if (failureRate === 0 && currentDelay > 200) {
        // All successful, can go faster
        currentDelay = Math.max(currentDelay * 0.8, 200);
      }
      
      // Delay between batches
      if (i + batchSize < uncachedArtists.length) {
        await new Promise(resolve => setTimeout(resolve, currentDelay));
      }
    }
    
    // Final cache save
    saveCache(cache);
    
    console.log(`âœ… Successfully loaded ${successCount} artists with genres`);
    return artistsWithGenres.filter((a: any) => a.id && a.genres && a.genres.length > 0);
  }

  onMount(async () => {
    try {
      // Load all streaming history JSON files
      loadingStatus = "LÃ¤dt Streaming-Daten...";
      const streamingFiles = [
        '/spotify-data/Streaming_History_Audio_2018-2020_0.json',
        '/spotify-data/Streaming_History_Audio_2020-2021_1.json',
        '/spotify-data/Streaming_History_Audio_2021_2.json',
        '/spotify-data/Streaming_History_Audio_2021_3.json',
        '/spotify-data/Streaming_History_Audio_2021-2022_4.json',
        '/spotify-data/Streaming_History_Audio_2022_5.json',
        '/spotify-data/Streaming_History_Audio_2022-2023_6.json',
        '/spotify-data/Streaming_History_Audio_2023_7.json',
        '/spotify-data/Streaming_History_Audio_2023-2024_8.json',
        '/spotify-data/Streaming_History_Audio_2024_9.json',
        '/spotify-data/Streaming_History_Audio_2024-2025_10.json',
        '/spotify-data/Streaming_History_Audio_2025_11.json'
      ];
      
      const streamingHistory = await loadStreamingHistory(streamingFiles);
      console.log(`Loaded ${streamingHistory.length} streaming entries`);
      
      // Extract unique artists
      loadingStatus = "Extrahiere Artists...";
      const uniqueArtists = Array.from(
        new Set(
          streamingHistory
            .map(d => d.master_metadata_album_artist_name)
            .filter((name): name is string => Boolean(name))
        )
      );
      console.log(`Found ${uniqueArtists.length} unique artists`);
      
      // Get Spotify token and fetch genres
      loadingStatus = "Verbinde mit Spotify API...";
      const token = await getSpotifyToken();
      
      loadingStatus = "Lade Artist-Genres...";
      const artistsWithGenres = await getArtistsWithGenres(uniqueArtists, token);
      console.log(`Found genres for ${artistsWithGenres.length} artists`);
      
      // Fallback auf Demo-Daten wenn keine Genres gefunden wurden
      if (artistsWithGenres.length === 0) {
        console.warn('No genres found from Spotify API, falling back to demo data');
        loadingStatus = "Keine Genres gefunden, verwende Demo-Daten...";
        
        const { createDemoGraphInput } = await import('$lib/graph');
        const input = createDemoGraphInput();
        
        const built = buildGraph(input, { 
          topK: 10, 
          sizeScale: 1.0, 
          minSize: 10, 
          maxSize: 45 
        });
        
        graphData.set(built);
        
        loadingStatus = "Berechne Layout...";
        const layoutResult = computeForceLayout(
          built.nodes, 
          built.edges, 
          { 
            seed: Math.floor(Math.random() * 10000),
            iterations: 150,
            chargeStrength: -150,
            linkDistance: 200,
            linkStrength: 0.05
          }
        );
        setPositions(layoutResult.positions);
        initVisible();
        isLoading = false;
        return;
      }
      
      // Transform data to graph input
      loadingStatus = "Erstelle Graph...";
      const input = transformSpotifyData(streamingHistory, artistsWithGenres);
      console.log(`Created graph with ${input.genreStats.length} genres and ${input.artists.length} artists`);
      
      const built = buildGraph(input, { 
        topK: 10, 
        sizeScale: 1.0, 
        minSize: 10, 
        maxSize: 45 
      });
      
      graphData.set(built);
      
      // Compute force layout with randomness
      loadingStatus = "Berechne Layout...";
      const layoutResult = computeForceLayout(
        built.nodes, 
        built.edges, 
        { 
          seed: Math.floor(Math.random() * 10000),
          iterations: 150,
          chargeStrength: -150,
          linkDistance: 200,
          linkStrength: 0.05
        }
      );
      setPositions(layoutResult.positions);
      
      // Initialize visible nodes
      initVisible();
      
      isLoading = false;
    } catch (error) {
      console.error('Error loading data:', error);
      loadingStatus = `Fehler: ${error instanceof Error ? error.message : String(error)}. Verwende Demo-Daten...`;
      
      // Fallback auf Demo-Daten bei jedem Fehler
      try {
        const { createDemoGraphInput } = await import('$lib/graph');
        const input = createDemoGraphInput();
        
        const built = buildGraph(input, { 
          topK: 10, 
          sizeScale: 1.0, 
          minSize: 10, 
          maxSize: 45 
        });
        
        graphData.set(built);
        
        const layoutResult = computeForceLayout(
          built.nodes, 
          built.edges, 
          { 
            seed: Math.floor(Math.random() * 10000),
            iterations: 150,
            chargeStrength: -150,
            linkDistance: 200,
            linkStrength: 0.05
          }
        );
        setPositions(layoutResult.positions);
        initVisible();
        isLoading = false;
      } catch (fallbackError) {
        loadingStatus = `Kritischer Fehler: ${fallbackError}`;
        console.error('Fallback failed:', fallbackError);
      }
    }
  });
</script>

<svelte:head>
  <title>Musical Brain Activity</title>
  <meta name="description" content="Neural Network Graph visualizing your music genre preferences" />
</svelte:head>

<main class="app">
  <header class="header">
    <h1 class="title">Musical Brain Activity</h1>
    <p class="subtitle">
      Explore your genre connections. Hover to reveal neighbors, click to pin genres.
    </p>
  </header>

  {#if isLoading}
    <div class="loading-screen">
      <div class="loading-content">
        <div class="spinner"></div>
        <p class="loading-text">{loadingStatus}</p>
      </div>
    </div>
  {:else}
    <div class="layout">
      <div class="controls">
        <ControlPanel />
      </div>
      
      <section class="graph-container">
        <GraphCanvas />
      </section>
    </div>
    
    <Tooltip />
  {/if}
</main>

<style>
  :global(body) {
    margin: 0;
    padding: 0;
    background: #0d1117;
    color: #e6edf3;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }
  
  .app {
    min-height: 100vh;
    padding: 24px;
    background: radial-gradient(ellipse at 20% 10%, #1b2838 0%, #0d1117 50%);
  }
  
  .header {
    margin-bottom: 24px;
    max-width: 1400px;
    margin-left: auto;
    margin-right: auto;
  }
  
  .title {
    font-size: 2.2rem;
    font-weight: 700;
    color: #1db954;
    margin: 0 0 8px 0;
    letter-spacing: -0.02em;
  }
  
  .subtitle {
    color: #8b949e;
    margin: 0;
    font-size: 15px;
    max-width: 600px;
  }
  
  .layout {
    display: flex;
    flex-direction: column;
    gap: 16px;
    max-width: 100%;
    margin: 0 auto;
    height: calc(100vh - 160px);
  }
  
  .controls {
    flex-shrink: 0;
  }
  
  .graph-container {
    flex: 1;
    background: rgba(255, 255, 255, 0.02);
    border-radius: 14px;
    padding: 8px;
    overflow: hidden;
  }
  
  .loading-screen {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 60vh;
  }
  
  .loading-content {
    text-align: center;
  }
  
  .spinner {
    width: 48px;
    height: 48px;
    border: 4px solid rgba(29, 185, 84, 0.1);
    border-top-color: #1db954;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 16px;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  .loading-text {
    color: #8b949e;
    font-size: 14px;
    margin: 0;
  }
</style>
